

## 索引分类

- 按 *数据结构* 分类：B+树索引、Hash索引、Full-text索引
- 按 *物理存储* 分类：聚簇索引（主键索引）、二级索引
- 按 *字段特性* 分类：主键索引、唯一索引、普通索引、前缀索引
- 按 *字段个数* 分类：单列索引、联合索引

## B+树索引

InnoDB 默认采用的索引类型

## 聚簇索引（主键索引）

- 如果有主键，默认使用主键作为聚簇索引的 key ；
- 没有主键，选择第一个不包含 NULL 值的列作为聚簇索引的 key ；
- 以上都没有，InnoDB 自动生成一个隐式自增 id 作为聚簇索引的 key 。

## 二级索引

- 主键索引的B+树叶子结点存放的是完整的用户记录；
- 二级索引的B+树的叶子结点存放的是主键值，而不是实际记录。

## 回表

1. 先检验二级索引中B+树的索引值，找到随影的叶子结点，获取主键值；
2. 然后再通过主键索引查询到对应的叶子结点，获取整行记录。

要查询两个B+树才能查到数据。

## 覆盖索引

当查询的数据能在二级索引的B+树叶子结点里查询到，就不需要在查询主键索引。

只需要差一个B+树就能找到数据。

## 联合索引

最左匹配原则。

针对范围查找有优化空间。

## 索引下推

MySQL5.6引入 *索引下推优化* （index condition pushdown），可以再联合索引遍历过程中，对联合索引中包含的字段先做判断，规律掉不满足条件的记录，减少回表次数。

## 索引区分度

建立联合索引的字段顺序，对索引效率也有很大影响。越靠前的字段，被用于索引过滤的概率越高，实际开发工作中建立联合索引时，要把区分度大的字段排在前面。
$$
区分度 = \frac{distinct(column)}{count(*)}
$$
MySQL 的查询优化器发现某个值出现在表的数据行中的百分比（30%）很高的时候，会忽略索引，进行全扫描。

