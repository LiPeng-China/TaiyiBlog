import{_ as e,X as l,Y as i,Z as a}from"./framework-7c2c1cd4.js";const s={},r=a(`<h2 id="一、连接服务" tabindex="-1"><a class="header-anchor" href="#一、连接服务" aria-hidden="true">#</a> 一、连接服务</h2><p>首先要连接 <strong>MySQL</strong> 服务，才能执行 SQL 语句，连接命令如下：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>mysql <span class="token parameter variable">-h</span> <span class="token variable">$ip</span> <span class="token parameter variable">-u</span> <span class="token variable">$user</span> <span class="token parameter variable">-p</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>1.1、建立 TCP 连接</p><p>MySQL 是基于 TCP 协议进行传输的，连接过程需要先经过 TCP 三次握手。</p><p>1.2、验证用户名和密码</p><p>如果 MySQL 服务正常运行，完成 TCP 连接的建立后，连接器开始验证用户名和密码。如果用户名和密码不对，收到 <em>Access denied for user</em> 的错误。</p><p>1.3、保存用户权限</p><p>如果用户名和密码正确，连接器或获取该用户的权限，保存起来，后续该用户在连接里的任何操作，都会基于连接开始时的读到的权限进行权限逻辑的判断。</p><blockquote><p>如果一个用户已经建立了连接，即使管理员中途修改了该用户的权限，也不会影响已经存在的连接权限。修改完成后，只有再新建连接才会使用新的权限设置。</p></blockquote><p>Q：如何查看 MySQL 服务被多少个客户端连接？</p><p>A：实行命令：<code>show processlist</code></p><p>Q：空连接会一直占用着吗？</p><p>A：不是。MySQL 定义了空连接的最大空闲时间，由 <code>wait_timeout</code> 参数控制，默认值是 8 小时，如果空闲时间超过这个时间，连接器就会自动将他断开。 命令 <code>show variables like &#39;wait_timeout&#39;;</code> 查看。 手动断开空闲连接：<code>kill connection +id;</code> 一个处于空闲状态的连接被服务器断开后，这个客户端并不会马上知道，等到客户端下次发起请求的时候才会收到报错：<em>ERROR 2013 (HY000): Lost connection to MySQL server during query</em> 。</p><p>Q：MySQL 的连接有限制吗？</p><p>A：MySQL 服务支持的最大连接数由 <code>max_connections</code> 参数控制，默认 151 ，超过这个值，系统会拒绝接线来的连接请求，并报错：<em>Too many connections</em> 。 命令 <code>show variables like &#39;max_connections&#39;;</code> 查看。</p><p>Q：如何解决长链接建立内存的问题？</p><p>A：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>// 短连接
连接 mysql 服务（TCP 三次握手）
执行sql
断开 mysql 服务（TCP 四次挥手）

// 长连接
连接 mysql 服务（TCP 三次握手）
执行sql
执行sql
执行sql
<span class="token punctuation">..</span><span class="token punctuation">..</span>
断开 mysql 服务（TCP 四次挥手
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>定期断开长连接。</li><li>客户端主动重置连接。MySQL 5.7 版本实现了 <code>mysql_reset_connection()</code> 函数的接口，注意这是接口函数不是命令，那么当客户端执行了一个很大的操作后，在代码里调用 mysql_reset_connection 函数来重置连接，达到释放内存的效果。这个过程不需要重连和重新做权限验证，但是会将连接恢复到刚刚创建完时的状态。</li></ul><h2 id="二、查询缓存" tabindex="-1"><a class="header-anchor" href="#二、查询缓存" aria-hidden="true">#</a> 二、查询缓存</h2><p>连接成功后，客户端向 MySQL 服务器发送 SQL 语句，MySQL 服务器收到 SQL 语句后，解析第一个字段，判断语句类型。</p><p>如果是查询语句，MySQL 会先去查询缓存里查找缓存数据，看看之前有没有执行过这一条命令，查询缓存以 key-value 的形式保存在内存中，key 为 SQL 语句，value 为查询结果。</p><p>如果命中缓存，就会直接返回 value 给客户端。如果没有命中，就继续往下执行等执行完后，查询的结果就会被存入查询缓存中。</p><p>为了保证数据的一致性，保重有更新操作，查询缓存就会被清空，因此命中率低。Mysql 8 版本直接将查询缓存删掉了。</p><h2 id="三、解析-sql" tabindex="-1"><a class="header-anchor" href="#三、解析-sql" aria-hidden="true">#</a> 三、解析 SQL</h2><p>正式执行 SQL 语句之前，对 SQL 语句做解析，有解析器完成。</p><ul><li>词法分析：MySQL 会根据输入得到字符串识别出关键字，构建 SQL 语法树，发辫后面模块获取 SQL 类型、表名、字段名、where 条件等；</li><li>语法分析：根据此法分析的结果和语法规则，判断输入的 SQL 语法是否满足 MySQL 语法。</li></ul><blockquote><p>解析器只负责构建语法树和检查语法，但是不会去查表或者字段存不存在</p></blockquote><h2 id="四、执行-sql" tabindex="-1"><a class="header-anchor" href="#四、执行-sql" aria-hidden="true">#</a> 四、执行 SQL</h2><p>4.1、Prepare 阶段：预处理器</p><ul><li>检查 SQL 语句中的表或者字段是否存在</li><li>将 <code>select *</code> 中的 <code>*</code> 扩展成表中的所有列</li></ul><p>4.2、Optimize 阶段：优化器</p><p>优化器负责将 SQL 查询语句的执行方案确定下来，比如表中有多个索引的时候，优化器会基于查询成本的考虑，来决定使用哪个索引。</p><p>在查询语句前面加 <code>explain</code> 命令，就会输出这条 SQL 语句的执行计划。</p><p>4.3、Execute 阶段：执行器</p><p>确定了执行方案，就要开始执行 SQL 语句，由执行器完成。在执行的过程中，执行器会和存储引擎交互，交互是以记录为单位的。</p><p>三种执行过程：</p><ul><li><p><strong>主键索引查询</strong></p><p>以 <code>select id from product where id = 1;</code> 为例。这条查询语句的查询条件用到了主键索引，而且是等值查询，同时主键 id 是唯一，不会有 id 相同的记录，所以优化器决定选用访问类型为 const 进行查询，也就是使用主键索引查询一条记录，那么执行器与存储引擎的执行流程是这样的：</p><ul><li>试行期第一次查询，会调用 <code>read_first_record</code> 函数指针指向的函数，因为优化器选择的访问类型为 <code>const</code> ，这个函数指针被指向为 InnoDB 引擎索引查询的接口，报条件交给存储引擎，让存储引擎定位符合条件的第一条记录；</li><li>存储引擎通过主键索引的 B+ 树结构定位到 id=1 的第一条记录。如果记录不存在，就会向执行器上报记录找不到的错误；如果记录存在，就会将记录返回给执行器；</li><li>执行器从存储引擎记录后，判断记录是否符合条件。如果符合条件，返回给客户端；反之跳过该记录；</li><li>执行器查询是一个 while 循环，所以还会再查询一次，调用 <code>read_record</code> 函数指针指向的函数，因为优化器选择的访问类型为 <code>const</code> ，这个函数指针被指向为一个永远返回 -1 的函数，执行器就退出循环，也就是结束查询了。</li></ul></li><li><p><strong>全表扫描</strong></p><p>以 <code>select * from product where name = &#39;iphone&#39;;</code> 为例。这条查询语句的查询条件没有用到索引，所以优化器决定选用访问类型为 ALL 进行查询，也就是全表扫描的方式查询，那么这时执行器与存储引擎的执行流程是这样的：</p><ul><li>执行器第一次查询，会调用 read_first_record 函数指针指向的函数，因为优化器选择的访问类型为 all，这个函数指针被指向为 InnoDB 引擎全扫描的接口，让存储引擎读取表中的第一条记录；</li><li>执行器会判断读到的这条记录的 name 是不是 iphone，如果不是则跳过；如果是则将记录发给客户的（是的没错，Server 层每从存储引擎读到一条记录就会发送给客户端，之所以客户端显示的时候是直接显示所有记录的，是因为客户端是等查询语句查询完成后，才会显示出所有的记录）。</li><li>执行器查询的过程是一个 while 循环，所以还会再查一次，会调用 read_record 函数指针指向的函数，因为优化器选择的访问类型为 all，read_record 函数指针指向的还是 InnoDB 引擎全扫描的接口，所以接着向存储引擎层要求继续读刚才那条记录的下一条记录，存储引擎把下一条记录取出后就将其返回给执行器（Server层），执行器继续判断条件，不符合查询条件即跳过该记录，否则发送到客户端；</li><li>一直重复上述过程，直到存储引擎把表中的所有记录读完，然后向执行器（Server层） 返回了读取完毕的信息；</li><li>执行器收到存储引擎报告的查询完毕的信息，退出循环，停止查询。</li></ul></li><li><p><strong>索引下推</strong></p><p>索引下推能够减少二级索引在查询时的回表操作，提高查询效率。因为它将 Server 层部分负责的事情交给存储引擎层去处理了。</p><p>以 <code>select * from t_user where age &gt; 20 and reward = 100000;</code> 为例。联合索引当遇到范围查询 (&gt;、&lt;) 就会停止匹配，也就是 age 字段能用到联合索引，但是 reward 字段则无法利用到索引。</p><p>不使用索引下推（MySQL 5.6 之前的版本）时，执行器与存储引擎的执行流程是这样的：</p><ul><li>Server 层首先调用存储引擎的接口定位到满足查询条件的第一条二级索引记录，也就是定位到 age &gt; 20 的第一条记录；</li><li>存储引擎根据二级索引的 B+ 树快速定位到这条记录后，获取主键值，然后<strong>进行回表操作</strong>，将完整的记录返回给 Server 层；</li><li>Server 层在判断该记录的 reward 是否等于 100000，如果成立则将其发送给客户端；否则跳过该记录；</li><li>接着，继续向存储引擎索要下一条记录，存储引擎在二级索引定位到记录后，获取主键值，然后回表操作，将完整的记录返回给 Server 层；</li><li>如此往复，直到存储引擎把表中的所有记录读完。</li></ul><p>使用索引下推后，判断记录的 reward 是否等于 100000 的工作交给了存储引擎层，过程如下 ：</p><ul><li>Server 层首先调用存储引擎的接口定位到满足查询条件的第一条二级索引记录，也就是定位到 age &gt; 20 的第一条记录；</li><li>存储引擎定位到二级索引后，先不执行回表操作，而是先判断一下该索引中包含的列（reward列）的条件（reward 是否等于 100000）是否成立。如果条件不成立，则直接跳过该二级索引。如果成立，则执行回表操作，将完成记录返回给 Server 层。</li><li>Server 层在判断其他的查询条件（本次查询没有其他条件）是否成立，如果成立则将其发送给客户端；否则跳过该记录，然后向存储引擎索要下一条记录。</li><li>如此往复，直到存储引擎把表中的所有记录读完。</li></ul></li></ul>`,39),n=[r];function d(o,c){return l(),i("div",null,n)}const t=e(s,[["render",d],["__file","01_select执行流程.html.vue"]]);export{t as default};
