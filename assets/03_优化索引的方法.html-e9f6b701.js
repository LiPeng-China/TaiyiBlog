import{_ as e,X as l,Y as i,Z as r}from"./framework-7c2c1cd4.js";const a={},o=r('<h2 id="一、前缀索引优化" tabindex="-1"><a class="header-anchor" href="#一、前缀索引优化" aria-hidden="true">#</a> 一、前缀索引优化</h2><p>使用字段中前几个字符建立索引。</p><p><strong>优势</strong></p><ul><li>减小索引字段大小，增加一个索引页中存储的索引值。</li></ul><p><strong>局限性</strong></p><ul><li><code>ORDER BY</code> 无法使用前缀索引；</li><li>无法把前缀索引用作覆盖索引。</li></ul><h2 id="二、覆盖索引优化" tabindex="-1"><a class="header-anchor" href="#二、覆盖索引优化" aria-hidden="true">#</a> 二、覆盖索引优化</h2><p>SQL 需要查询的字段包含在二级索引中，不需要回表操作。</p><p><strong>优势</strong></p><ul><li>避免回表，较少 I/O 操作。</li></ul><h2 id="三、主键索引自增" tabindex="-1"><a class="header-anchor" href="#三、主键索引自增" aria-hidden="true">#</a> 三、主键索引自增</h2><p>使用主键自增，每次插入新记录，都只追加操作，不需要移动数据。</p><p><strong>页分裂</strong></p><ul><li>主键不增增，每次插入新记录，可能会插入到数据页中间的某个位置，需要一动其它数据来满足新纪录的插入，甚至需要从一个页面复制数据到两一个页面；</li><li>可能会造成大量的内存碎片，导致索引结构不紧凑，从而影响查询效率。</li></ul><p><strong>主键字段不宜过长</strong></p><ul><li>主键字段长度越小，意味着二级索引的叶子结点越小，二级索引占用的空间就越小。</li></ul><h2 id="四、索引设置-not-null" tabindex="-1"><a class="header-anchor" href="#四、索引设置-not-null" aria-hidden="true">#</a> 四、索引设置 NOT NULL</h2><p>索引列设置 NOT NULL 约束。</p><ul><li>NULL 值会时索引、索引统计、值比较都更复杂（<code>count</code> 会忽略值为 NULL 的行），导致优化器难以优化。</li><li>至少占用一字节的空间存储 NULL值列表。</li></ul><h2 id="五、防止索引失效" tabindex="-1"><a class="header-anchor" href="#五、防止索引失效" aria-hidden="true">#</a> 五、防止索引失效</h2><p>索引失效的查询语句：</p><ul><li><strong>左或左右模糊匹配</strong>，如 <code>like %xx</code> 和 <code>like %xx%</code> ，会导致索引失效</li><li>在查询条件中对索引列做<strong>计算、函数、类型转换</strong>操作，会导致索引失效；</li><li>联合索引需要遵循<strong>最左匹配原则</strong>；</li><li><code>WHERE</code> 子句中，<code>OR</code> 前面的列是索引列而后面的列不是索引列会导致索引失效。</li></ul>',22),n=[o];function t(d,s){return l(),i("div",null,n)}const h=e(a,[["render",t],["__file","03_优化索引的方法.html.vue"]]);export{h as default};
