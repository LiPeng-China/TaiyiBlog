import{_ as l,X as i,Y as a,Z as r}from"./framework-7c2c1cd4.js";const e={},n=r('<h2 id="需求" tabindex="-1"><a class="header-anchor" href="#需求" aria-hidden="true">#</a> 需求</h2><ul><li>在尽可能少的磁盘 I/O 操作中完成查询工作；</li><li>能高效的查找某一记录，同时支持范围查找。</li></ul><h2 id="数组" tabindex="-1"><a class="header-anchor" href="#数组" aria-hidden="true">#</a> 数组</h2><p><strong>优点</strong></p><ul><li>支持二分查找，时间复杂度 O(n) ;</li></ul><p><strong>缺点</strong></p><ul><li>但插入性能太低。</li></ul><h2 id="二分查找树" tabindex="-1"><a class="header-anchor" href="#二分查找树" aria-hidden="true">#</a> 二分查找树</h2><p><strong>优点</strong></p><ul><li>解决了插入新元素性能开销问题。</li></ul><p><strong>缺点</strong></p><ul><li>不平衡，极端情况会变成一个链表。查找的时间复杂度会变成 O(n) ；</li><li>树高等于查询磁盘的 I/O 次数，越高，查询效率越低；</li><li>不支持范围查找。</li></ul><h2 id="平衡二叉查找树-avl" tabindex="-1"><a class="header-anchor" href="#平衡二叉查找树-avl" aria-hidden="true">#</a> 平衡二叉查找树（AVL）</h2><p><strong>优点</strong></p><ul><li>解决了极端情况下退化成链表的问题，查询复杂度 O(logn)</li></ul><p><strong>缺点</strong></p><ul><li>树高影响查询效率</li><li>不支持范围查找。</li></ul><h2 id="b树" tabindex="-1"><a class="header-anchor" href="#b树" aria-hidden="true">#</a> B树</h2><p><strong>优点</strong></p><ul><li>解决了树高问题；</li></ul><p><strong>缺点</strong></p><ul><li>每个节点都包含数据，增加磁盘 I/O 操作，同时占用内存资源；</li><li>范围查找需要中序遍历，设计多借点的磁盘 I/O 问题，从而导致整体速度下降。</li></ul><h2 id="b-树" tabindex="-1"><a class="header-anchor" href="#b-树" aria-hidden="true">#</a> B+树</h2><ul><li>B+ 树的非叶子结点只存放索引。因此在数据量相同的情况下，相比于既存索引又存记录的B树，B+树的非叶子节点可以存放更多的索引，更 <strong>矮胖</strong> ，查询底层节点的 I/O 次数更少；</li><li>B+树的非叶子节点让其在插入、删除的效率都更高；</li><li>B+ 树所有数据存放在叶子结点中，叶子结点之间通过双向链表连接，有利于范围查找。</li></ul>',24),t=[n];function s(h,o){return i(),a("div",null,t)}const u=l(e,[["render",s],["__file","04_为什么采用B_树作为索引.html.vue"]]);export{u as default};
